from Algorithms.ost import ost
from Algorithms.combinations import c_1, c_k
from typing import List


def main_func(m: List[int], g: List[int]):
    """Выполняет подсчёт обнаруживающей способности циклического кода
    с образующим полиномом g для ошибок всех кратностей от 1 до
    длины кодовой комбинации включительно.
    Здесь m - информационный вектор."""
    k = len(m)  # количество информационных разрядов
    n = k + len(g) - 1  # длина кодовой комбинации
    r = n - k  # количество разрядов проверочного кода
    v = []  # вспомогательный вектор для вычисления проверочного кода
    v.extend(m)
    e = []  # проверочный код
    for i in range(r):
        v.append(0)
        e.append(0)
    ost(e, v, g)  # получение остатка 'e' при делении 'v' на 'g'
    m.extend(e)  # конкатенация информационного вектора 'm' и проверочного кода 'e'
    count, comb = c_1(m, g)  # count - количество обнаруженных ошибок; comb - общее количество ошибок
    print('Обнаруживающая способность для ошибки кратности 1 = ', count / comb * 100)
    print('Ошибок всего: {}. Обнаружено: {}'.format(comb, count))
    print('--------------------------------------')
    for i in range(1, n):
        count, comb = c_k(m, g, i)  # count - количество обнаруженных ошибок; comb - общее количество ошибок
        print('Обнаруживающая способность для ошибки кратности {} = '.format(i + 1), count / comb * 100)
        print('Ошибок всего: {}. Обнаружено: {}'.format(comb, count))
        print('--------------------------------------')
